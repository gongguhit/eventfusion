// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_IMU_DV_H_
#define FLATBUFFERS_GENERATED_IMU_DV_H_

#pragma GCC system_header
#pragma clang system_header

#include "../external/flatbuffers/flatbuffers.h"

#include "cvector.hpp"

#include <Eigen/Core>

#include <numbers>
#include <ostream>

namespace dv {

struct IMUFlatbuffer;
struct IMU;

struct IMUPacketFlatbuffer;
struct IMUPacket;

bool operator==(const IMU &lhs, const IMU &rhs);
bool operator==(const IMUPacket &lhs, const IMUPacket &rhs);

inline const flatbuffers::TypeTable *IMUTypeTable();

inline const flatbuffers::TypeTable *IMUPacketTypeTable();

struct IMU : public flatbuffers::NativeTable {
	typedef IMUFlatbuffer TableType;

	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "dv.IMU";
	}

	int64_t timestamp;
	float temperature;
	float accelerometerX;
	float accelerometerY;
	float accelerometerZ;
	float gyroscopeX;
	float gyroscopeY;
	float gyroscopeZ;
	float magnetometerX;
	float magnetometerY;
	float magnetometerZ;

	IMU() :
		timestamp(0),
		temperature(0.0f),
		accelerometerX(0.0f),
		accelerometerY(0.0f),
		accelerometerZ(0.0f),
		gyroscopeX(0.0f),
		gyroscopeY(0.0f),
		gyroscopeZ(0.0f),
		magnetometerX(0.0f),
		magnetometerY(0.0f),
		magnetometerZ(0.0f) {
	}

	// Generated Constructor
	IMU(int64_t _timestamp, float _temperature, float _accelerometerX, float _accelerometerY, float _accelerometerZ,
		float _gyroscopeX, float _gyroscopeY, float _gyroscopeZ, float _magnetometerX, float _magnetometerY,
		float _magnetometerZ) :
		timestamp{_timestamp},
		temperature{_temperature},
		accelerometerX{_accelerometerX},
		accelerometerY{_accelerometerY},
		accelerometerZ{_accelerometerZ},
		gyroscopeX{_gyroscopeX},
		gyroscopeY{_gyroscopeY},
		gyroscopeZ{_gyroscopeZ},
		magnetometerX{_magnetometerX},
		magnetometerY{_magnetometerY},
		magnetometerZ{_magnetometerZ} {
	}

	/**
	 * Get measured acceleration in m/s^2.
	 * @return Measured acceleration.
	 */
	[[nodiscard]] Eigen::Vector3f getAccelerations() const {
		constexpr float earthG = 9.81007f;
		return {accelerometerX * earthG, accelerometerY * earthG, accelerometerZ * earthG};
	}

	/**
	 * Get measured angular velocities in rad/s.
	 * @return Measured angular velocities.
	 */
	[[nodiscard]] Eigen::Vector3f getAngularVelocities() const {
		constexpr float deg2rad = std::numbers::pi_v<float> / 180.0f;
		return {gyroscopeX * deg2rad, gyroscopeY * deg2rad, gyroscopeZ * deg2rad};
	}
};

inline bool operator==(const IMU &lhs, const IMU &rhs) {
	return (lhs.timestamp == rhs.timestamp) && (lhs.temperature == rhs.temperature)
		&& (lhs.accelerometerX == rhs.accelerometerX) && (lhs.accelerometerY == rhs.accelerometerY)
		&& (lhs.accelerometerZ == rhs.accelerometerZ) && (lhs.gyroscopeX == rhs.gyroscopeX)
		&& (lhs.gyroscopeY == rhs.gyroscopeY) && (lhs.gyroscopeZ == rhs.gyroscopeZ)
		&& (lhs.magnetometerX == rhs.magnetometerX) && (lhs.magnetometerY == rhs.magnetometerY)
		&& (lhs.magnetometerZ == rhs.magnetometerZ);
}

struct IMUFlatbuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef IMU NativeTableType;

	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return IMUTypeTable();
	}

	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "dv.IMU";
	}

	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TIMESTAMP      = 4,
		VT_TEMPERATURE    = 6,
		VT_ACCELEROMETERX = 8,
		VT_ACCELEROMETERY = 10,
		VT_ACCELEROMETERZ = 12,
		VT_GYROSCOPEX     = 14,
		VT_GYROSCOPEY     = 16,
		VT_GYROSCOPEZ     = 18,
		VT_MAGNETOMETERX  = 20,
		VT_MAGNETOMETERY  = 22,
		VT_MAGNETOMETERZ  = 24
	};

	/// Timestamp (µs).
	int64_t timestamp() const {
		return GetField<int64_t>(VT_TIMESTAMP, 0);
	}

	/// Temperature, measured in °C.
	float temperature() const {
		return GetField<float>(VT_TEMPERATURE, 0.0f);
	}

	/// Acceleration in the X axis, measured in g (9.81m/s²).
	float accelerometerX() const {
		return GetField<float>(VT_ACCELEROMETERX, 0.0f);
	}

	/// Acceleration in the Y axis, measured in g (9.81m/s²).
	float accelerometerY() const {
		return GetField<float>(VT_ACCELEROMETERY, 0.0f);
	}

	/// Acceleration in the Z axis, measured in g (9.81m/s²).
	float accelerometerZ() const {
		return GetField<float>(VT_ACCELEROMETERZ, 0.0f);
	}

	/// Rotation in the X axis, measured in °/s.
	float gyroscopeX() const {
		return GetField<float>(VT_GYROSCOPEX, 0.0f);
	}

	/// Rotation in the Y axis, measured in °/s.
	float gyroscopeY() const {
		return GetField<float>(VT_GYROSCOPEY, 0.0f);
	}

	/// Rotation in the Z axis, measured in °/s.
	float gyroscopeZ() const {
		return GetField<float>(VT_GYROSCOPEZ, 0.0f);
	}

	/// Magnetometer X axis, measured in µT (magnetic flux density).
	float magnetometerX() const {
		return GetField<float>(VT_MAGNETOMETERX, 0.0f);
	}

	/// Magnetometer Y axis, measured in µT (magnetic flux density).
	float magnetometerY() const {
		return GetField<float>(VT_MAGNETOMETERY, 0.0f);
	}

	/// Magnetometer Z axis, measured in µT (magnetic flux density).
	float magnetometerZ() const {
		return GetField<float>(VT_MAGNETOMETERZ, 0.0f);
	}

	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_TIMESTAMP)
			&& VerifyField<float>(verifier, VT_TEMPERATURE) && VerifyField<float>(verifier, VT_ACCELEROMETERX)
			&& VerifyField<float>(verifier, VT_ACCELEROMETERY) && VerifyField<float>(verifier, VT_ACCELEROMETERZ)
			&& VerifyField<float>(verifier, VT_GYROSCOPEX) && VerifyField<float>(verifier, VT_GYROSCOPEY)
			&& VerifyField<float>(verifier, VT_GYROSCOPEZ) && VerifyField<float>(verifier, VT_MAGNETOMETERX)
			&& VerifyField<float>(verifier, VT_MAGNETOMETERY) && VerifyField<float>(verifier, VT_MAGNETOMETERZ)
			&& verifier.EndTable();
	}

	IMU *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(IMU *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static void UnPackToFrom(
		IMU *_o, const IMUFlatbuffer *_fb, const flatbuffers::resolver_function_t *_resolver = nullptr);
	static flatbuffers::Offset<IMUFlatbuffer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IMU *_o,
		const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IMUBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;

	void add_timestamp(int64_t timestamp) {
		fbb_.AddElement<int64_t>(IMUFlatbuffer::VT_TIMESTAMP, timestamp, 0);
	}

	void add_temperature(float temperature) {
		fbb_.AddElement<float>(IMUFlatbuffer::VT_TEMPERATURE, temperature, 0.0f);
	}

	void add_accelerometerX(float accelerometerX) {
		fbb_.AddElement<float>(IMUFlatbuffer::VT_ACCELEROMETERX, accelerometerX, 0.0f);
	}

	void add_accelerometerY(float accelerometerY) {
		fbb_.AddElement<float>(IMUFlatbuffer::VT_ACCELEROMETERY, accelerometerY, 0.0f);
	}

	void add_accelerometerZ(float accelerometerZ) {
		fbb_.AddElement<float>(IMUFlatbuffer::VT_ACCELEROMETERZ, accelerometerZ, 0.0f);
	}

	void add_gyroscopeX(float gyroscopeX) {
		fbb_.AddElement<float>(IMUFlatbuffer::VT_GYROSCOPEX, gyroscopeX, 0.0f);
	}

	void add_gyroscopeY(float gyroscopeY) {
		fbb_.AddElement<float>(IMUFlatbuffer::VT_GYROSCOPEY, gyroscopeY, 0.0f);
	}

	void add_gyroscopeZ(float gyroscopeZ) {
		fbb_.AddElement<float>(IMUFlatbuffer::VT_GYROSCOPEZ, gyroscopeZ, 0.0f);
	}

	void add_magnetometerX(float magnetometerX) {
		fbb_.AddElement<float>(IMUFlatbuffer::VT_MAGNETOMETERX, magnetometerX, 0.0f);
	}

	void add_magnetometerY(float magnetometerY) {
		fbb_.AddElement<float>(IMUFlatbuffer::VT_MAGNETOMETERY, magnetometerY, 0.0f);
	}

	void add_magnetometerZ(float magnetometerZ) {
		fbb_.AddElement<float>(IMUFlatbuffer::VT_MAGNETOMETERZ, magnetometerZ, 0.0f);
	}

	explicit IMUBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}

	IMUBuilder &operator=(const IMUBuilder &);

	flatbuffers::Offset<IMUFlatbuffer> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o         = flatbuffers::Offset<IMUFlatbuffer>(end);
		return o;
	}
};

inline flatbuffers::Offset<IMUFlatbuffer> CreateIMU(flatbuffers::FlatBufferBuilder &_fbb, int64_t timestamp = 0,
	float temperature = 0.0f, float accelerometerX = 0.0f, float accelerometerY = 0.0f, float accelerometerZ = 0.0f,
	float gyroscopeX = 0.0f, float gyroscopeY = 0.0f, float gyroscopeZ = 0.0f, float magnetometerX = 0.0f,
	float magnetometerY = 0.0f, float magnetometerZ = 0.0f) {
	IMUBuilder builder_(_fbb);
	builder_.add_timestamp(timestamp);
	builder_.add_magnetometerZ(magnetometerZ);
	builder_.add_magnetometerY(magnetometerY);
	builder_.add_magnetometerX(magnetometerX);
	builder_.add_gyroscopeZ(gyroscopeZ);
	builder_.add_gyroscopeY(gyroscopeY);
	builder_.add_gyroscopeX(gyroscopeX);
	builder_.add_accelerometerZ(accelerometerZ);
	builder_.add_accelerometerY(accelerometerY);
	builder_.add_accelerometerX(accelerometerX);
	builder_.add_temperature(temperature);
	return builder_.Finish();
}

flatbuffers::Offset<IMUFlatbuffer> CreateIMU(
	flatbuffers::FlatBufferBuilder &_fbb, const IMU *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IMUPacket : public flatbuffers::NativeTable {
	typedef IMUPacketFlatbuffer TableType;

	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "dv.IMUPacket";
	}

	dv::cvector<IMU> elements;

	IMUPacket() {
	}

	// Generated Constructor
	IMUPacket(const dv::cvector<IMU> &_elements) : elements{_elements} {
	}

	friend std::ostream &operator<<(std::ostream &os, const IMUPacket &packet) {
		if (packet.elements.empty()) {
			os << fmt::format("IMUPacket containing 0 measurements");
			return os;
		}

		const int64_t lowestTime  = packet.elements.front().timestamp;
		const int64_t highestTime = packet.elements.back().timestamp;

		os << fmt::format("IMUPacket containing {} measurements within {}μs duration; time range within [{}; {}]",
			packet.elements.size(), highestTime - lowestTime, lowestTime, highestTime);
		return os;
	}
};

inline bool operator==(const IMUPacket &lhs, const IMUPacket &rhs) {
	return (lhs.elements == rhs.elements);
}

struct IMUPacketFlatbuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef IMUPacket NativeTableType;
	static FLATBUFFERS_CONSTEXPR const char *identifier = "IMUS";

	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return IMUPacketTypeTable();
	}

	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "dv.IMUPacket";
	}

	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_ELEMENTS = 4
	};

	const flatbuffers::Vector<flatbuffers::Offset<IMUFlatbuffer>> *elements() const {
		return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<IMUFlatbuffer>> *>(VT_ELEMENTS);
	}

	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_ELEMENTS) && verifier.VerifyVector(elements())
			&& verifier.VerifyVectorOfTables(elements()) && verifier.EndTable();
	}

	IMUPacket *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(IMUPacket *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static void UnPackToFrom(
		IMUPacket *_o, const IMUPacketFlatbuffer *_fb, const flatbuffers::resolver_function_t *_resolver = nullptr);
	static flatbuffers::Offset<IMUPacketFlatbuffer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IMUPacket *_o,
		const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IMUPacketBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;

	void add_elements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<IMUFlatbuffer>>> elements) {
		fbb_.AddOffset(IMUPacketFlatbuffer::VT_ELEMENTS, elements);
	}

	explicit IMUPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}

	IMUPacketBuilder &operator=(const IMUPacketBuilder &);

	flatbuffers::Offset<IMUPacketFlatbuffer> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o         = flatbuffers::Offset<IMUPacketFlatbuffer>(end);
		return o;
	}
};

inline flatbuffers::Offset<IMUPacketFlatbuffer> CreateIMUPacket(flatbuffers::FlatBufferBuilder &_fbb,
	flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<IMUFlatbuffer>>> elements = 0) {
	IMUPacketBuilder builder_(_fbb);
	builder_.add_elements(elements);
	return builder_.Finish();
}

inline flatbuffers::Offset<IMUPacketFlatbuffer> CreateIMUPacketDirect(
	flatbuffers::FlatBufferBuilder &_fbb, const std::vector<flatbuffers::Offset<IMUFlatbuffer>> *elements = nullptr) {
	auto elements__ = elements ? _fbb.CreateVector<flatbuffers::Offset<IMUFlatbuffer>>(*elements) : 0;
	return dv::CreateIMUPacket(_fbb, elements__);
}

flatbuffers::Offset<IMUPacketFlatbuffer> CreateIMUPacket(flatbuffers::FlatBufferBuilder &_fbb, const IMUPacket *_o,
	const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline IMU *IMUFlatbuffer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new IMU();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void IMUFlatbuffer::UnPackTo(IMU *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void) _o;
	(void) _resolver;
	UnPackToFrom(_o, this, _resolver);
}

inline void IMUFlatbuffer::UnPackToFrom(
	IMU *_o, const IMUFlatbuffer *_fb, const flatbuffers::resolver_function_t *_resolver) {
	(void) _o;
	(void) _fb;
	(void) _resolver;
	{
		auto _e       = _fb->timestamp();
		_o->timestamp = _e;
	};
	{
		auto _e         = _fb->temperature();
		_o->temperature = _e;
	};
	{
		auto _e            = _fb->accelerometerX();
		_o->accelerometerX = _e;
	};
	{
		auto _e            = _fb->accelerometerY();
		_o->accelerometerY = _e;
	};
	{
		auto _e            = _fb->accelerometerZ();
		_o->accelerometerZ = _e;
	};
	{
		auto _e        = _fb->gyroscopeX();
		_o->gyroscopeX = _e;
	};
	{
		auto _e        = _fb->gyroscopeY();
		_o->gyroscopeY = _e;
	};
	{
		auto _e        = _fb->gyroscopeZ();
		_o->gyroscopeZ = _e;
	};
	{
		auto _e           = _fb->magnetometerX();
		_o->magnetometerX = _e;
	};
	{
		auto _e           = _fb->magnetometerY();
		_o->magnetometerY = _e;
	};
	{
		auto _e           = _fb->magnetometerZ();
		_o->magnetometerZ = _e;
	};
}

inline flatbuffers::Offset<IMUFlatbuffer> IMUFlatbuffer::Pack(
	flatbuffers::FlatBufferBuilder &_fbb, const IMU *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateIMU(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IMUFlatbuffer> CreateIMU(
	flatbuffers::FlatBufferBuilder &_fbb, const IMU *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void) _rehasher;
	(void) _o;

	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const IMU *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = {&_fbb, _o, _rehasher};

	(void) _va;
	auto _timestamp      = _o->timestamp;
	auto _temperature    = _o->temperature;
	auto _accelerometerX = _o->accelerometerX;
	auto _accelerometerY = _o->accelerometerY;
	auto _accelerometerZ = _o->accelerometerZ;
	auto _gyroscopeX     = _o->gyroscopeX;
	auto _gyroscopeY     = _o->gyroscopeY;
	auto _gyroscopeZ     = _o->gyroscopeZ;
	auto _magnetometerX  = _o->magnetometerX;
	auto _magnetometerY  = _o->magnetometerY;
	auto _magnetometerZ  = _o->magnetometerZ;
	return dv::CreateIMU(_fbb, _timestamp, _temperature, _accelerometerX, _accelerometerY, _accelerometerZ, _gyroscopeX,
		_gyroscopeY, _gyroscopeZ, _magnetometerX, _magnetometerY, _magnetometerZ);
}

inline IMUPacket *IMUPacketFlatbuffer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new IMUPacket();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void IMUPacketFlatbuffer::UnPackTo(IMUPacket *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void) _o;
	(void) _resolver;
	UnPackToFrom(_o, this, _resolver);
}

inline void IMUPacketFlatbuffer::UnPackToFrom(
	IMUPacket *_o, const IMUPacketFlatbuffer *_fb, const flatbuffers::resolver_function_t *_resolver) {
	(void) _o;
	(void) _fb;
	(void) _resolver;
	{
		auto _e = _fb->elements();
		if (_e) {
			_o->elements.resize(_e->size());
			for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) {
				_e->Get(_i)->UnPackTo(&_o->elements[_i], _resolver);
			}
		}
	};
}

inline flatbuffers::Offset<IMUPacketFlatbuffer> IMUPacketFlatbuffer::Pack(
	flatbuffers::FlatBufferBuilder &_fbb, const IMUPacket *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreateIMUPacket(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IMUPacketFlatbuffer> CreateIMUPacket(
	flatbuffers::FlatBufferBuilder &_fbb, const IMUPacket *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void) _rehasher;
	(void) _o;

	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const IMUPacket *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = {&_fbb, _o, _rehasher};

	(void) _va;
	auto _elements = _o->elements.size() ? _fbb.CreateVector<flatbuffers::Offset<IMUFlatbuffer>>(
						 _o->elements.size(),
						 [](size_t i, _VectorArgs *__va) {
							 return CreateIMU(*__va->__fbb, &__va->__o->elements[i], __va->__rehasher);
						 },
						 &_va)
										 : 0;
	return dv::CreateIMUPacket(_fbb, _elements);
}

inline const flatbuffers::TypeTable *IMUTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
		{flatbuffers::ET_LONG,  0, -1},
        {flatbuffers::ET_FLOAT, 0, -1},
        {flatbuffers::ET_FLOAT, 0, -1},
		{flatbuffers::ET_FLOAT, 0, -1},
        {flatbuffers::ET_FLOAT, 0, -1},
        {flatbuffers::ET_FLOAT, 0, -1},
		{flatbuffers::ET_FLOAT, 0, -1},
        {flatbuffers::ET_FLOAT, 0, -1},
        {flatbuffers::ET_FLOAT, 0, -1},
		{flatbuffers::ET_FLOAT, 0, -1},
        {flatbuffers::ET_FLOAT, 0, -1}
    };
	static const char *const names[]       = {"timestamp", "temperature", "accelerometerX", "accelerometerY",
			  "accelerometerZ", "gyroscopeX", "gyroscopeY", "gyroscopeZ", "magnetometerX", "magnetometerY", "magnetometerZ"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 11, type_codes, nullptr, nullptr, names};
	return &tt;
}

inline const flatbuffers::TypeTable *IMUPacketTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
		{flatbuffers::ET_SEQUENCE, 1, 0}
    };
	static const flatbuffers::TypeFunction type_refs[] = {IMUTypeTable};
	static const char *const names[]                   = {"elements"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names};
	return &tt;
}

inline const dv::IMUPacketFlatbuffer *GetIMUPacket(const void *buf) {
	return flatbuffers::GetRoot<dv::IMUPacketFlatbuffer>(buf);
}

inline const dv::IMUPacketFlatbuffer *GetSizePrefixedIMUPacket(const void *buf) {
	return flatbuffers::GetSizePrefixedRoot<dv::IMUPacketFlatbuffer>(buf);
}

inline const char *IMUPacketIdentifier() {
	return "IMUS";
}

inline bool IMUPacketBufferHasIdentifier(const void *buf) {
	return flatbuffers::BufferHasIdentifier(buf, IMUPacketIdentifier());
}

inline bool VerifyIMUPacketBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifyBuffer<dv::IMUPacketFlatbuffer>(IMUPacketIdentifier());
}

inline bool VerifySizePrefixedIMUPacketBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifySizePrefixedBuffer<dv::IMUPacketFlatbuffer>(IMUPacketIdentifier());
}

inline void FinishIMUPacketBuffer(
	flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<dv::IMUPacketFlatbuffer> root) {
	fbb.Finish(root, IMUPacketIdentifier());
}

inline void FinishSizePrefixedIMUPacketBuffer(
	flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<dv::IMUPacketFlatbuffer> root) {
	fbb.FinishSizePrefixed(root, IMUPacketIdentifier());
}

inline std::unique_ptr<IMUPacket> UnPackIMUPacket(
	const void *buf, const flatbuffers::resolver_function_t *res = nullptr) {
	return std::unique_ptr<IMUPacket>(GetIMUPacket(buf)->UnPack(res));
}

} // namespace dv

// fmt compatibility for ostream class printing.
template<>
struct fmt::formatter<dv::IMUPacket> : fmt::ostream_formatter {};

#endif // FLATBUFFERS_GENERATED_IMU_DV_H_
