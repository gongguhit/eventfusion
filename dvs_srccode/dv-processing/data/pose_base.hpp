// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_POSE_DV_H_
#define FLATBUFFERS_GENERATED_POSE_DV_H_

#include "../external/flatbuffers/flatbuffers.h"

#include "cstring.hpp"
#include "geometry_types_base.hpp"

namespace dv {

struct PoseFlatbuffer;
struct Pose;

bool operator==(const Pose &lhs, const Pose &rhs);

inline const flatbuffers::TypeTable *PoseTypeTable();

struct Pose : public flatbuffers::NativeTable {
	typedef PoseFlatbuffer TableType;

	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "dv.Pose";
	}

	int64_t timestamp;
	Vec3f translation;
	Quaternion rotation;
	dv::cstring referenceFrame;
	dv::cstring targetFrame;

	Pose() : timestamp(0) {
	}

	// Generated Constructor
	Pose(int64_t _timestamp, const Vec3f &_translation, const Quaternion &_rotation, const dv::cstring &_referenceFrame,
		const dv::cstring &_targetFrame) :
		timestamp{_timestamp},
		translation{_translation},
		rotation{_rotation},
		referenceFrame{_referenceFrame},
		targetFrame{_targetFrame} {
	}

	friend std::ostream &operator<<(std::ostream &os, const Pose &packet) {
		os << fmt::format("Pose containing transformation within frames [{} -> {}] at time [{}]", packet.referenceFrame,
			packet.targetFrame, packet.timestamp);
		return os;
	}
};

inline bool operator==(const Pose &lhs, const Pose &rhs) {
	return (lhs.timestamp == rhs.timestamp) && (lhs.translation == rhs.translation) && (lhs.rotation == rhs.rotation)
		&& (lhs.referenceFrame == rhs.referenceFrame) && (lhs.targetFrame == rhs.targetFrame);
}

/// A struct holding timestamp and pose.
struct PoseFlatbuffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
	typedef Pose NativeTableType;
	static FLATBUFFERS_CONSTEXPR const char *identifier = "POSE";

	static const flatbuffers::TypeTable *MiniReflectTypeTable() {
		return PoseTypeTable();
	}

	static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
		return "dv.Pose";
	}

	enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
		VT_TIMESTAMP      = 4,
		VT_TRANSLATION    = 6,
		VT_ROTATION       = 8,
		VT_REFERENCEFRAME = 10,
		VT_TARGETFRAME    = 12
	};

	/// Timestamp (Âµs).
	int64_t timestamp() const {
		return GetField<int64_t>(VT_TIMESTAMP, 0);
	}

	/// Translational vector.
	const Vec3f *translation() const {
		return GetStruct<const Vec3f *>(VT_TRANSLATION);
	}

	/// Rotation quaternion.
	const Quaternion *rotation() const {
		return GetStruct<const Quaternion *>(VT_ROTATION);
	}

	/// Name of the reference frame (transforming from)
	const flatbuffers::String *referenceFrame() const {
		return GetPointer<const flatbuffers::String *>(VT_REFERENCEFRAME);
	}

	/// Name of the target frame (transforming into)
	const flatbuffers::String *targetFrame() const {
		return GetPointer<const flatbuffers::String *>(VT_TARGETFRAME);
	}

	bool Verify(flatbuffers::Verifier &verifier) const {
		return VerifyTableStart(verifier) && VerifyField<int64_t>(verifier, VT_TIMESTAMP)
			&& VerifyField<Vec3f>(verifier, VT_TRANSLATION) && VerifyField<Quaternion>(verifier, VT_ROTATION)
			&& VerifyOffset(verifier, VT_REFERENCEFRAME) && verifier.VerifyString(referenceFrame())
			&& VerifyOffset(verifier, VT_TARGETFRAME) && verifier.VerifyString(targetFrame()) && verifier.EndTable();
	}

	Pose *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	void UnPackTo(Pose *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
	static void UnPackToFrom(
		Pose *_o, const PoseFlatbuffer *_fb, const flatbuffers::resolver_function_t *_resolver = nullptr);
	static flatbuffers::Offset<PoseFlatbuffer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pose *_o,
		const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PoseBuilder {
	flatbuffers::FlatBufferBuilder &fbb_;
	flatbuffers::uoffset_t start_;

	void add_timestamp(int64_t timestamp) {
		fbb_.AddElement<int64_t>(PoseFlatbuffer::VT_TIMESTAMP, timestamp, 0);
	}

	void add_translation(const Vec3f *translation) {
		fbb_.AddStruct(PoseFlatbuffer::VT_TRANSLATION, translation);
	}

	void add_rotation(const Quaternion *rotation) {
		fbb_.AddStruct(PoseFlatbuffer::VT_ROTATION, rotation);
	}

	void add_referenceFrame(flatbuffers::Offset<flatbuffers::String> referenceFrame) {
		fbb_.AddOffset(PoseFlatbuffer::VT_REFERENCEFRAME, referenceFrame);
	}

	void add_targetFrame(flatbuffers::Offset<flatbuffers::String> targetFrame) {
		fbb_.AddOffset(PoseFlatbuffer::VT_TARGETFRAME, targetFrame);
	}

	explicit PoseBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
		start_ = fbb_.StartTable();
	}

	PoseBuilder &operator=(const PoseBuilder &);

	flatbuffers::Offset<PoseFlatbuffer> Finish() {
		const auto end = fbb_.EndTable(start_);
		auto o         = flatbuffers::Offset<PoseFlatbuffer>(end);
		return o;
	}
};

inline flatbuffers::Offset<PoseFlatbuffer> CreatePose(flatbuffers::FlatBufferBuilder &_fbb, int64_t timestamp = 0,
	const Vec3f *translation = 0, const Quaternion *rotation = 0,
	flatbuffers::Offset<flatbuffers::String> referenceFrame = 0,
	flatbuffers::Offset<flatbuffers::String> targetFrame    = 0) {
	PoseBuilder builder_(_fbb);
	builder_.add_timestamp(timestamp);
	builder_.add_targetFrame(targetFrame);
	builder_.add_referenceFrame(referenceFrame);
	builder_.add_rotation(rotation);
	builder_.add_translation(translation);
	return builder_.Finish();
}

inline flatbuffers::Offset<PoseFlatbuffer> CreatePoseDirect(flatbuffers::FlatBufferBuilder &_fbb, int64_t timestamp = 0,
	const Vec3f *translation = 0, const Quaternion *rotation = 0, const char *referenceFrame = nullptr,
	const char *targetFrame = nullptr) {
	auto referenceFrame__ = referenceFrame ? _fbb.CreateString(referenceFrame) : 0;
	auto targetFrame__    = targetFrame ? _fbb.CreateString(targetFrame) : 0;
	return dv::CreatePose(_fbb, timestamp, translation, rotation, referenceFrame__, targetFrame__);
}

flatbuffers::Offset<PoseFlatbuffer> CreatePose(
	flatbuffers::FlatBufferBuilder &_fbb, const Pose *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline Pose *PoseFlatbuffer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
	auto _o = new Pose();
	UnPackTo(_o, _resolver);
	return _o;
}

inline void PoseFlatbuffer::UnPackTo(Pose *_o, const flatbuffers::resolver_function_t *_resolver) const {
	(void) _o;
	(void) _resolver;
	UnPackToFrom(_o, this, _resolver);
}

inline void PoseFlatbuffer::UnPackToFrom(
	Pose *_o, const PoseFlatbuffer *_fb, const flatbuffers::resolver_function_t *_resolver) {
	(void) _o;
	(void) _fb;
	(void) _resolver;
	{
		auto _e       = _fb->timestamp();
		_o->timestamp = _e;
	};
	{
		auto _e = _fb->translation();
		if (_e)
			_o->translation = *_e;
	};
	{
		auto _e = _fb->rotation();
		if (_e)
			_o->rotation = *_e;
	};
	{
		auto _e = _fb->referenceFrame();
		if (_e)
			_o->referenceFrame = dv::cstring(_e->c_str(), _e->size());
	};
	{
		auto _e = _fb->targetFrame();
		if (_e)
			_o->targetFrame = dv::cstring(_e->c_str(), _e->size());
	};
}

inline flatbuffers::Offset<PoseFlatbuffer> PoseFlatbuffer::Pack(
	flatbuffers::FlatBufferBuilder &_fbb, const Pose *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	return CreatePose(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PoseFlatbuffer> CreatePose(
	flatbuffers::FlatBufferBuilder &_fbb, const Pose *_o, const flatbuffers::rehasher_function_t *_rehasher) {
	(void) _rehasher;
	(void) _o;

	struct _VectorArgs {
		flatbuffers::FlatBufferBuilder *__fbb;
		const Pose *__o;
		const flatbuffers::rehasher_function_t *__rehasher;
	} _va = {&_fbb, _o, _rehasher};

	(void) _va;
	auto _timestamp      = _o->timestamp;
	auto _translation    = &_o->translation;
	auto _rotation       = &_o->rotation;
	auto _referenceFrame = _o->referenceFrame.empty() ? 0 : _fbb.CreateString(_o->referenceFrame);
	auto _targetFrame    = _o->targetFrame.empty() ? 0 : _fbb.CreateString(_o->targetFrame);
	return dv::CreatePose(_fbb, _timestamp, _translation, _rotation, _referenceFrame, _targetFrame);
}

inline const flatbuffers::TypeTable *PoseTypeTable() {
	static const flatbuffers::TypeCode type_codes[] = {
		{flatbuffers::ET_LONG,     0, -1},
        {flatbuffers::ET_SEQUENCE, 0, 0 },
        {flatbuffers::ET_SEQUENCE, 0, 1 },
		{flatbuffers::ET_STRING,   0, -1},
        {flatbuffers::ET_STRING,   0, -1}
    };
	static const flatbuffers::TypeFunction type_refs[] = {Vec3fTypeTable, QuaternionTypeTable};
	static const char *const names[]       = {"timestamp", "translation", "rotation", "referenceFrame", "targetFrame"};
	static const flatbuffers::TypeTable tt = {flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names};
	return &tt;
}

inline const dv::PoseFlatbuffer *GetPose(const void *buf) {
	return flatbuffers::GetRoot<dv::PoseFlatbuffer>(buf);
}

inline const dv::PoseFlatbuffer *GetSizePrefixedPose(const void *buf) {
	return flatbuffers::GetSizePrefixedRoot<dv::PoseFlatbuffer>(buf);
}

inline const char *PoseIdentifier() {
	return "POSE";
}

inline bool PoseBufferHasIdentifier(const void *buf) {
	return flatbuffers::BufferHasIdentifier(buf, PoseIdentifier());
}

inline bool VerifyPoseBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifyBuffer<dv::PoseFlatbuffer>(PoseIdentifier());
}

inline bool VerifySizePrefixedPoseBuffer(flatbuffers::Verifier &verifier) {
	return verifier.VerifySizePrefixedBuffer<dv::PoseFlatbuffer>(PoseIdentifier());
}

inline void FinishPoseBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<dv::PoseFlatbuffer> root) {
	fbb.Finish(root, PoseIdentifier());
}

inline void FinishSizePrefixedPoseBuffer(
	flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<dv::PoseFlatbuffer> root) {
	fbb.FinishSizePrefixed(root, PoseIdentifier());
}

inline std::unique_ptr<Pose> UnPackPose(const void *buf, const flatbuffers::resolver_function_t *res = nullptr) {
	return std::unique_ptr<Pose>(GetPose(buf)->UnPack(res));
}

} // namespace dv

// fmt compatibility for ostream class printing.
template<>
struct fmt::formatter<dv::Pose> : fmt::ostream_formatter {};

#endif // FLATBUFFERS_GENERATED_POSE_DV_H_
